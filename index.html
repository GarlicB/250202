<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WaveAttack MAX - 업그레이드 버전</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="introControls">
      <button id="skipIntro" class="game-button">인트로 스킵</button>
      <button id="startGame" class="game-button">게임 시작</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <!-- 옵션(디버그) 모달 -->
    <div id="optionsModal" class="modal">
      <h2>테스트 옵션</h2>
      <div>
        <label>배경 색상:</label>
        <input type="color" id="bgColorPicker" value="#111111" />
        <button id="applyBgColor">적용</button>
      </div>
      <div>
        <label>총알 테스트:</label>
        <button id="spawnTestBullet">플레이어 위치에서 총알 발사</button>
      </div>
      <div>
        <label>레벨업 테스트:</label>
        <button id="simulateLevelUp">레벨업 효과 실행</button>
      </div>
      <div>
        <label>사용 가능한 스킬:</label>
        <div style="margin-left: 20px">
          <div>
            <input
              type="checkbox"
              id="skill_regenAura"
              data-skill="regenAura"
            />
            <label for="skill_regenAura">회복 오라 (Q키)</label>
          </div>
          <div>
            <input
              type="checkbox"
              id="skill_homingLaser"
              data-skill="homingLaser"
            />
            <label for="skill_homingLaser">유도 레이저 (W키)</label>
          </div>
          <div>
            <input
              type="checkbox"
              id="skill_chainLightning"
              data-skill="chainLightning"
            />
            <label for="skill_chainLightning">연쇄 번개 (E키)</label>
          </div>
          <div>
            <input
              type="checkbox"
              id="skill_meteorShower"
              data-skill="meteorShower"
            />
            <label for="skill_meteorShower">메테오 (R키)</label>
          </div>
        </div>
      </div>
      <div>
        <label>몹 디자인 테스트:</label>
        <button id="spawnTestEnemy">테스트 몹 소환</button>
      </div>
      <div style="text-align: right; margin-top: 10px">
        <button id="closeOptions">닫기</button>
      </div>
    </div>
    <button id="debugButton">디버그 옵션</button>
    <script type="module">
      import {
        GameState,
        MAX_PARTICLES,
        MAX_EFFECTS,
        MAX_BULLETS,
        MAX_ENEMIES,
        STORY_TEXT,
        BOSS_QUOTES,
        ItemType,
        SkillType,
        ShopItems,
        WaveSystem,
        SkillUpgrades,
      } from "./js/constants.js";
      import { Modal } from "./js/Modal.js";
      import { BulletManager } from "./js/BulletManager.js";

      // 스킬 클래스
      class Skill {
        constructor(game, type) {
          this.game = game;
          this.type = type;
          this.level = 0;
          this.maxLevel = 5;
          this.cooldown = 0;
          this.cooldownTimer = 0;
          this.active = false;
          this.duration = 0;
          this.durationTimer = 0;
          this.init();
        }
        init() {
          switch (this.type) {
            case SkillType.REGEN_AURA:
              this.cooldown = 8;
              this.duration = 5;
              this.range = 200;
              this.healAmount = 2;
              break;
            case SkillType.HOMING_LASER:
              this.cooldown = 2;
              this.damage = 25;
              this.projectileSpeed = 400;
              this.trackingStrength = 0.15;
              break;
            case SkillType.CHAIN_LIGHTNING:
              this.cooldown = 4;
              this.damage = 20;
              this.chainCount = 4;
              this.chainRange = 150;
              break;
            case SkillType.METEOR_SHOWER:
              this.cooldown = 6;
              this.duration = 3;
              this.meteorCount = 8;
              this.damage = 35;
              break;
          }
        }
        update(dt) {
          if (this.cooldownTimer > 0) this.cooldownTimer -= dt;
          if (this.active) {
            this.durationTimer -= dt;
            if (this.durationTimer <= 0) this.deactivate();
            else this.updateEffect(dt);
          }
        }
        updateEffect(dt) {
          switch (this.type) {
            case SkillType.REGEN_AURA:
              this.updateRegenAura(dt);
              break;
            case SkillType.HOMING_LASER:
              this.updateHomingLaser(dt);
              break;
            case SkillType.CHAIN_LIGHTNING:
              this.updateChainLightning(dt);
              break;
            case SkillType.METEOR_SHOWER:
              this.updateMeteorShower(dt);
              break;
          }
        }
        updateRegenAura(dt) {
          if (this.game.player.hp < this.game.player.maxHp)
            this.game.player.hp = Math.min(
              this.game.player.hp + this.healAmount * dt,
              this.game.player.maxHp
            );
          if (Math.random() < dt * 3) {
            const angle = Math.random() * Math.PI * 2,
              distance = Math.random() * this.range;
            this.game.effectManager.createHealEffect(
              this.game.player.x + Math.cos(angle) * distance,
              this.game.player.y + Math.sin(angle) * distance
            );
          }
        }
        updateHomingLaser(dt) {
          const colors = ["#ff0", "#f0f", "#0ff", "#f80"]; // 컬러풀한 레이저 색상
          const angle = Math.PI * 1.5; // 위쪽 방향
          const speed = this.projectileSpeed;
          const color = colors[Math.floor(Math.random() * colors.length)];

          this.game.bulletManager.spawnPlayerBullet(
            this.game.player.x,
            this.game.player.y,
            Math.cos(angle),
            Math.sin(angle),
            {
              size: 15,
              speed: speed,
              damage: this.damage,
              color: color,
              isLaser: true,
              penetrate: true,
            }
          );
        }
        updateChainLightning(dt) {
          const angle = Math.PI * 1.5; // 위쪽 방향
          const zigzagAmplitude = 30; // 지그재그 진폭
          const zigzagFrequency = 0.1; // 지그재그 주기

          this.game.bulletManager.spawnPlayerBullet(
            this.game.player.x,
            this.game.player.y,
            Math.cos(angle),
            Math.sin(angle),
            {
              size: 12,
              speed: 300,
              damage: this.damage,
              color: "#7df",
              isZigzag: true,
              zigzagAmplitude,
              zigzagFrequency,
              time: 0,
              chainRange: this.chainRange,
              chainCount: this.chainCount,
              originalX: this.game.player.x,
            }
          );
        }
        updateMeteorShower(dt) {
          if (Math.random() < dt * this.meteorCount) {
            const x = Math.random() * this.game.canvas.width;
            const y = -50;
            const targetX = x + (Math.random() - 0.5) * 200;
            const targetY = this.game.canvas.height + 50;
            const angle = Math.atan2(targetY - y, targetX - x);
            const speed = 300;
            const vx = Math.cos(angle) * speed;
            const vy = Math.sin(angle) * speed;

            this.game.bulletManager.spawnPlayerBullet(
              x,
              y,
              vx / speed,
              vy / speed,
              {
                size: 20,
                speed: speed,
                damage: this.damage,
                color: "#f66",
              }
            );
          }
        }
        activate() {
          if (this.cooldownTimer <= 0) {
            this.active = true;
            this.cooldownTimer = this.cooldown;
            this.durationTimer = this.duration;
            return true;
          }
          return false;
        }
        deactivate() {
          this.active = false;
          this.durationTimer = 0;
        }
        findNearestEnemy() {
          let nearest = null,
            minDistance = Infinity;
          for (let enemy of this.game.enemies) {
            if (enemy.dead) continue;
            const dist = this.game.distance(
              this.game.player.x,
              this.game.player.y,
              enemy.x,
              enemy.y
            );
            if (dist < minDistance) {
              minDistance = dist;
              nearest = enemy;
            }
          }
          return nearest;
        }
        findNearestEnemyExcluding(sourceEnemy, excludeList) {
          let nearest = null,
            minDistance = Infinity;
          for (let enemy of this.game.enemies) {
            if (enemy.dead || excludeList.includes(enemy)) continue;
            const dist = this.game.distance(
              sourceEnemy.x,
              sourceEnemy.y,
              enemy.x,
              enemy.y
            );
            if (dist < this.chainRange && dist < minDistance) {
              minDistance = dist;
              nearest = enemy;
            }
          }
          return nearest;
        }
        levelUp() {
          if (this.level >= this.maxLevel) return false;
          this.level++;
          this.upgradeEffects();
          return true;
        }
        upgradeEffects() {
          switch (this.type) {
            case SkillType.REGEN_AURA:
              this.healAmount *= 1.2;
              this.range *= 1.1;
              break;
            case SkillType.HOMING_LASER:
              this.damage *= 1.3;
              this.cooldown *= 0.9;
              break;
            case SkillType.CHAIN_LIGHTNING:
              this.damage *= 1.2;
              this.chainCount++;
              this.chainRange *= 1.1;
              break;
            case SkillType.METEOR_SHOWER:
              this.damage *= 1.25;
              this.meteorCount++;
              break;
          }
        }
      }

      // Player 클래스
      class Player {
        constructor(game) {
          this.game = game;
          this.x = game.canvas.width / 2;
          this.y = game.canvas.height - 80;
          this.radius = 16;
          this.speed = 5;
          this.hp = 20;
          this.maxHp = 20;
          this.level = 1;
          this.xp = 0;
          this.nextXp = 8;
          this.bulletDamage = 4;
          this.bulletSize = 10;
          this.attackSpeed = 0.2;
          this.attackTimer = 0;
          this.buffs = [];
          this.keyState = { left: false, right: false, up: false, down: false };
          this.skills = {
            regenAura: new Skill(game, SkillType.REGEN_AURA),
            homingLaser: new Skill(game, SkillType.HOMING_LASER),
            chainLightning: new Skill(game, SkillType.CHAIN_LIGHTNING),
            meteorShower: new Skill(game, SkillType.METEOR_SHOWER),
          };
        }
        update(dt) {
          this.move(dt);
          this.shoot(dt);
          this.updateBuffs(dt);
          for (let key in this.skills) this.skills[key].update(dt);
          if (
            this.keyState.left ||
            this.keyState.right ||
            this.keyState.up ||
            this.keyState.down
          )
            this.game.particleSystem.createTrail(this.x, this.y);
        }
        move(dt) {
          let dx = 0,
            dy = 0;
          if (this.keyState.left) dx = -1;
          if (this.keyState.right) dx = 1;
          if (this.keyState.up) dy = -1;
          if (this.keyState.down) dy = 1;
          if (dx || dy) {
            let mag = Math.sqrt(dx * dx + dy * dy);
            dx /= mag;
            dy /= mag;
            this.x = Math.max(
              this.radius,
              Math.min(
                this.game.canvas.width - this.radius,
                this.x + dx * this.speed
              )
            );
            this.y = Math.max(
              this.radius,
              Math.min(
                this.game.canvas.height - this.radius,
                this.y + dy * this.speed
              )
            );
          }
        }
        shoot(dt) {
          this.attackTimer += dt;
          if (this.attackTimer >= this.attackSpeed) {
            this.attackTimer = 0;
            this.game.bulletManager.spawnPlayerBullet(this.x, this.y, 0, -1);
          }
        }
        draw(ctx) {
          ctx.save();
          ctx.fillStyle = "#2bf";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          let barWidth = this.radius * 1.2 * (this.hp / this.maxHp);
          ctx.fillStyle = "#fff";
          ctx.fillRect(
            this.x - this.radius * 0.6,
            this.y - this.radius - 10,
            barWidth,
            3
          );
          ctx.restore();
        }
        takeDamage(amount) {
          this.hp -= amount;
          if (this.hp <= 0) {
            this.hp = 0;
            this.game.state = GameState.OVER;
          }
        }
        addXp(amount) {
          this.xp += amount;
          if (this.xp >= this.nextXp) this.levelUp();
        }
        levelUp() {
          this.level++;
          this.xp -= this.nextXp;
          this.nextXp = Math.floor(this.nextXp * 1.3 + 10);
          this.game.state = GameState.SKILL_SELECT;
          this.game.particleSystem.createLevelUpEffect(this.x, this.y);

          // 스킬 선택지 3개를 랜덤하게 생성
          const allSkills = [...Object.values(SkillUpgrades)]; // 배열 복사
          this.game.skillChoices = [];

          for (let i = 0; i < 3 && allSkills.length > 0; i++) {
            const randomIndex = Math.floor(Math.random() * allSkills.length);
            this.game.skillChoices.push(allSkills[randomIndex]);
            allSkills.splice(randomIndex, 1);
          }
        }
        updateBuffs(dt) {
          this.buffs = this.buffs.filter((buff) => {
            buff.duration -= dt;
            return buff.duration > 0;
          });
        }
        // 추가: 활성화 메서드
        activateSkill(skillKey) {
          try {
            const skill = this.skills[skillKey];
            if (!skill) {
              console.warn(`스킬 ${skillKey}가 존재하지 않습니다.`);
              return false;
            }

            if (skill.cooldownTimer <= 0) {
              skill.active = true;
              skill.cooldownTimer = skill.cooldown;
              skill.durationTimer = skill.duration;
              console.log(`${skillKey} 스킬 활성화`);
              return true;
            } else {
              console.warn(
                `${skillKey} 스킬을 활성화할 수 없습니다. (쿨타임: ${Math.max(
                  0,
                  skill.cooldownTimer
                ).toFixed(1)}초)`
              );
              return false;
            }
          } catch (error) {
            console.error(`스킬 활성화 중 오류 발생: ${error.message}`);
            return false;
          }
        }
        // 추가: 방어막 버프 메서드
        addShield(duration) {
          // 예시로 버프 배열에 방어막 효과를 추가
          this.buffs.push({ type: "shield", duration: duration });
          console.log("방어막 버프 추가:", duration);
        }
      }

      // Enemy 클래스 (몹 디자인 개선)
      class Enemy {
        constructor(game, type = "normal") {
          this.game = game;
          this.type = type;
          this.dead = false;
          this.init();
        }
        init() {
          switch (this.type) {
            case "normal":
              this.initNormal();
              break;
            case "boss":
              this.initBoss();
              break;
            case "miniBoss":
              this.initMiniBoss();
              break;
          }
        }
        initNormal() {
          this.x = Math.random() * (this.game.canvas.width - 50) + 25;
          this.y = Math.random() * 50 + 25;
          this.vx = 0;
          this.vy = 1 + Math.random() * 0.4;
          this.size = 24;
          this.hp = 10;
          this.maxHp = 10;
          this.bulletTimer = 0;
          this.bulletInterval = 2;
        }
        initBoss() {
          this.x = this.game.canvas.width / 2;
          this.y = 60;
          this.vx = 0;
          this.vy = 0.5;
          this.size = 100;
          this.hp = 400;
          this.maxHp = 400;
          this.bulletTimer = 0;
          this.bulletInterval = 1;
        }
        initMiniBoss() {
          this.x = this.game.canvas.width / 2;
          this.y = 80;
          this.vx = 0;
          this.vy = 0.8;
          this.size = 60;
          this.hp = 120;
          this.maxHp = 120;
          this.bulletTimer = 0;
          this.bulletInterval = 1.5;
        }
        update(dt) {
          if (this.dead) return;
          this.x += this.vx;
          this.y += this.vy;
          this.x = Math.max(
            this.size,
            Math.min(this.game.canvas.width - this.size, this.x)
          );
          this.y = Math.max(
            this.size,
            Math.min(this.game.canvas.height - this.size, this.y)
          );
          this.bulletTimer += dt;
          if (this.bulletTimer >= this.bulletInterval) {
            this.bulletTimer = 0;
            this.shoot();
          }
        }
        shoot() {
          if (this.dead) return;
          const angle = Math.atan2(
            this.game.player.y - this.y,
            this.game.player.x - this.x
          );
          this.game.bulletManager.spawnEnemyBullet(
            this.x,
            this.y,
            Math.cos(angle),
            Math.sin(angle)
          );
        }
        draw(ctx) {
          if (this.dead) return;
          ctx.save();
          if (this.type === "boss") {
            const grd = ctx.createRadialGradient(
              this.x,
              this.y,
              this.size * 0.2,
              this.x,
              this.y,
              this.size
            );
            grd.addColorStop(0, "#ff4444");
            grd.addColorStop(1, "#800000");
            ctx.fillStyle = grd;
            ctx.shadowColor = "#ff0000";
            ctx.shadowBlur = 20;
          } else if (this.type === "miniBoss") {
            const grd = ctx.createRadialGradient(
              this.x,
              this.y,
              this.size * 0.3,
              this.x,
              this.y,
              this.size
            );
            grd.addColorStop(0, "#44ff44");
            grd.addColorStop(1, "#008000");
            ctx.fillStyle = grd;
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#fff";
          } else {
            const grd = ctx.createRadialGradient(
              this.x,
              this.y,
              this.size * 0.1,
              this.x,
              this.y,
              this.size
            );
            grd.addColorStop(0, "#ff8888");
            grd.addColorStop(1, "#aa0000");
            ctx.fillStyle = grd;
          }
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          if (this.type === "miniBoss") ctx.stroke();
          if (this.hp < this.maxHp) {
            const barWidth = this.size * 2,
              barHeight = 4,
              barX = this.x - barWidth / 2,
              barY = this.y - this.size - 10,
              hpRatio = this.hp / this.maxHp;
            ctx.fillStyle = "#333";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.fillStyle = "#f00";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
          }
          ctx.restore();
        }
        takeDamage(amount) {
          if (this.dead) return;
          this.hp -= amount;
          this.game.particleSystem.createHitEffect(this.x, this.y);
          if (this.hp <= 0) {
            this.hp = 0;
            this.dead = true;
            this.game.addScore(this.getScoreValue());
            // 적 처치 시 경험치 추가
            const xpValue =
              this.type === "boss" ? 50 : this.type === "miniBoss" ? 30 : 10;
            this.game.player.addXp(xpValue);
            this.dropItems();
            // Reduce particle count to 10 to lower resource usage
            this.game.particleSystem.createExplosion(
              this.x,
              this.y,
              "#f66",
              10
            );
          }
        }
        getScoreValue() {
          if (this.type === "boss") return 1000;
          else if (this.type === "miniBoss") return 500;
          return 100;
        }
        dropItems() {
          const random = Math.random();
          if (this.type === "boss") {
            this.game.itemManager.spawnItem(ItemType.GEM, this.x, this.y);
            return;
          }
          if (random < 0.4)
            this.game.itemManager.spawnItem(ItemType.COIN, this.x, this.y);
          else if (random < 0.5)
            this.game.itemManager.spawnItem(ItemType.HEALTH, this.x, this.y);
          else if (random < 0.55)
            this.game.itemManager.spawnItem(ItemType.POWER, this.x, this.y);
          else if (random < 0.58)
            this.game.itemManager.spawnItem(ItemType.SPEED, this.x, this.y);
          else if (random < 0.6)
            this.game.itemManager.spawnItem(ItemType.SHIELD, this.x, this.y);
        }
      }

      // Item, ItemManager, EffectManager, ParticleSystem 클래스는 기존 로직 유지
      class Item {
        constructor(game, type, x, y) {
          this.game = game;
          this.type = type;
          this.x = x;
          this.y = y;
          this.vy = 1;
          this.collected = false;
          switch (type) {
            case ItemType.COIN:
              this.size = 16;
              this.color = "#FD7";
              this.value = 1;
              break;
            case ItemType.GEM:
              this.size = 20;
              this.color = "#7DF";
              this.value = 5;
              break;
            case ItemType.HEALTH:
              this.size = 16;
              this.color = "#F77";
              this.value = 3;
              break;
            case ItemType.POWER:
              this.size = 16;
              this.color = "#77F";
              this.duration = 5;
              this.value = 1.5;
              break;
            case ItemType.SPEED:
              this.size = 16;
              this.color = "#7F7";
              this.duration = 5;
              this.value = 1.5;
              break;
            case ItemType.SHIELD:
              this.size = 20;
              this.color = "#FF7";
              this.duration = 3;
              break;
          }
        }
        update(dt) {
          if (this.collected) return;
          this.y += this.vy;
          const dist = this.game.distance(
            this.x,
            this.y,
            this.game.player.x,
            this.game.player.y
          );
          if (dist < 100) {
            const dx = this.game.player.x - this.x,
              dy = this.game.player.y - this.y,
              mag = Math.sqrt(dx * dx + dy * dy);
            if (mag > 0) {
              this.x += (dx / mag) * 5;
              this.y += (dy / mag) * 5;
            }
          }
          if (dist < this.game.player.radius + this.size) {
            this.collected = true;
            this.applyEffect();
          }
        }
        draw(ctx) {
          if (this.collected) return;
          ctx.save();
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        applyEffect() {
          switch (this.type) {
            case ItemType.COIN:
              this.game.addScore(this.value);
              break;
            case ItemType.GEM:
              this.game.addGems(this.value);
              break;
            case ItemType.HEALTH:
              this.game.player.hp = Math.min(
                this.game.player.hp + this.value,
                this.game.player.maxHp
              );
              break;
            case ItemType.POWER:
              this.game.player.buffs.push({
                type: "power",
                value: this.value,
                duration: this.duration,
              });
              break;
            case ItemType.SPEED:
              this.game.player.buffs.push({
                type: "speed",
                value: this.value,
                duration: this.duration,
              });
              break;
            case ItemType.SHIELD:
              this.game.player.addShield(this.duration);
              break;
          }
        }
      }
      class ItemManager {
        constructor(game) {
          this.game = game;
          this.items = [];
        }
        update(dt) {
          this.items = this.items.filter((item) => !item.collected);
          for (let item of this.items) item.update(dt);
        }
        draw(ctx) {
          for (let item of this.items) item.draw(ctx);
        }
        spawnItem(type, x, y) {
          this.items.push(new Item(this.game, type, x, y));
        }
      }
      class EffectManager {
        constructor(game) {
          this.game = game;
          this.effects = [];
        }
        update(dt) {
          this.effects = this.effects.filter((effect) => {
            effect.update(dt);
            return !effect.finished;
          });
          if (this.effects.length > MAX_EFFECTS)
            this.effects.length = MAX_EFFECTS;
        }
        draw(ctx) {
          for (let effect of this.effects) effect.draw(ctx);
        }
        createHealEffect(x, y) {
          this.effects.push({
            x,
            y,
            size: 10,
            alpha: 1,
            color: "#7f7",
            duration: 0.5,
            timer: 0,
            finished: false,
            update(dt) {
              this.timer += dt;
              this.alpha = 1 - this.timer / this.duration;
              this.size += dt * 20;
              if (this.timer >= this.duration) this.finished = true;
            },
            draw(ctx) {
              ctx.save();
              ctx.globalAlpha = this.alpha;
              ctx.fillStyle = this.color;
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            },
          });
        }
        createLightningEffect(x1, y1, x2, y2) {
          const segments = 5,
            points = [{ x: x1, y: y1 }];
          for (let i = 1; i < segments; i++) {
            const t = i / segments,
              x = x1 + (x2 - x1) * t,
              y = y1 + (y2 - y1) * t,
              offset = (Math.random() - 0.5) * 30;
            points.push({ x: x + offset, y: y + offset });
          }
          points.push({ x: x2, y: y2 });
          this.effects.push({
            points,
            alpha: 1,
            color: "#ff0",
            duration: 0.2,
            timer: 0,
            finished: false,
            update(dt) {
              this.timer += dt;
              this.alpha = 1 - this.timer / this.duration;
              if (this.timer >= this.duration) this.finished = true;
            },
            draw(ctx) {
              ctx.save();
              ctx.globalAlpha = this.alpha;
              ctx.strokeStyle = this.color;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(this.points[0].x, this.points[0].y);
              for (let i = 1; i < this.points.length; i++)
                ctx.lineTo(this.points[i].x, this.points[i].y);
              ctx.stroke();
              ctx.restore();
            },
          });
        }
        createMeteor(x, y, damage) {
          const targetX = x + (Math.random() - 0.5) * 100,
            targetY = this.game.canvas.height + 50;
          this.effects.push({
            x,
            y,
            targetX,
            targetY,
            size: 20,
            speed: 500,
            damage,
            color: "#f66",
            finished: false,
            update(dt) {
              const dx = this.targetX - this.x,
                dy = this.targetY - this.y,
                dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < this.speed * dt) {
                this.finished = true;
                return;
              }
              const vx = (dx / dist) * this.speed,
                vy = (dy / dist) * this.speed;
              this.x += vx * dt;
              this.y += vy * dt;
              for (let enemy of this.game.enemies) {
                if (
                  !enemy.dead &&
                  this.game.distance(this.x, this.y, enemy.x, enemy.y) <
                    enemy.size + this.size
                )
                  enemy.takeDamage(this.damage);
              }
            },
            draw(ctx) {
              ctx.save();
              ctx.fillStyle = this.color;
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
              ctx.fill();
              const gradient = ctx.createLinearGradient(
                this.x,
                this.y,
                this.x,
                this.y - 40
              );
              gradient.addColorStop(0, "#f66");
              gradient.addColorStop(1, "transparent");
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.moveTo(this.x - this.size, this.y);
              ctx.lineTo(this.x + this.size, this.y);
              ctx.lineTo(this.x, this.y - 40);
              ctx.closePath();
              ctx.fill();
              ctx.restore();
            },
          });
        }
      }
      class ParticleSystem {
        constructor(game) {
          this.game = game;
          this.particles = [];
        }
        update(dt) {
          this.particles = this.particles.filter((particle) => {
            particle.update(dt);
            return !particle.finished;
          });
          if (this.particles.length > MAX_PARTICLES)
            this.particles.length = MAX_PARTICLES;
        }
        draw(ctx) {
          for (let particle of this.particles) particle.draw(ctx);
        }
        createExplosion(x, y, color = "#f66", count = 20) {
          for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count,
              speed = 100 + Math.random() * 100;
            this.particles.push({
              x,
              y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              size: 3 + Math.random() * 3,
              color,
              alpha: 1,
              life: 0.5 + Math.random() * 0.5,
              finished: false,
              update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.size *= 0.95;
                this.life -= dt;
                this.alpha = this.life;
                if (this.life <= 0) this.finished = true;
              },
              draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              },
            });
          }
        }
        createHitEffect(x, y) {
          for (let i = 0; i < 5; i++) {
            const angle = Math.random() * Math.PI * 2,
              speed = 50 + Math.random() * 50;
            this.particles.push({
              x,
              y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              size: 2 + Math.random() * 2,
              color: "#fff",
              alpha: 1,
              life: 0.2 + Math.random() * 0.2,
              finished: false,
              update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
                this.alpha = this.life * 5;
                if (this.life <= 0) this.finished = true;
              },
              draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              },
            });
          }
        }
        createTrail(x, y, color = "#4af") {
          this.particles.push({
            x,
            y,
            size: 3,
            color,
            alpha: 0.5,
            life: 0.3,
            finished: false,
            update(dt) {
              this.life -= dt;
              this.alpha = this.life * 2;
              this.size *= 0.95;
              if (this.life <= 0) this.finished = true;
            },
            draw(ctx) {
              ctx.save();
              ctx.globalAlpha = this.alpha;
              ctx.fillStyle = this.color;
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            },
          });
        }
        createLevelUpEffect(x, y) {
          const colors = ["#4af", "#ff4", "#f4f", "#4f4"];
          for (let i = 0; i < 40; i++) {
            const angle = (Math.PI * 2 * i) / 40,
              speed = 200 + Math.random() * 100,
              color = colors[Math.floor(Math.random() * colors.length)];
            this.particles.push({
              x,
              y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              size: 4 + Math.random() * 4,
              color,
              alpha: 1,
              life: 1 + Math.random() * 0.5,
              finished: false,
              update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy += 200 * dt;
                this.size *= 0.98;
                this.life -= dt;
                this.alpha = this.life;
                if (this.life <= 0) this.finished = true;
              },
              draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              },
            });
          }
        }
      }

      // Shop 클래스
      class Shop {
        constructor(game) {
          this.game = game;
          this.items = Object.values(ShopItems);
          this.selectedIndex = 0;
        }
        draw(ctx) {
          const width = this.game.canvas.width,
            height = this.game.canvas.height;
          ctx.save();
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.fillRect(0, 0, width, height);
          ctx.fillStyle = "#fff";
          ctx.font = "bold 40px Arial";
          ctx.textAlign = "center";
          ctx.fillText("상점", width / 2, 100);
          ctx.font = "24px Arial";
          ctx.fillText(`보유 젬: ${this.game.gems || 0}`, width / 2, 150);
          const startY = 200,
            itemHeight = 80;
          for (let index = 0; index < this.items.length; index++) {
            const item = this.items[index],
              y = startY + index * itemHeight,
              isSelected = index === this.selectedIndex;
            if (isSelected) {
              ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
              ctx.fillRect(width / 4, y - 10, width / 2, itemHeight - 10);
            }
            ctx.fillStyle = isSelected ? "#4af" : "#fff";
            ctx.font = "bold 24px Arial";
            ctx.fillText(item.name, width / 2, y + 20);
            ctx.font = "18px Arial";
            ctx.fillText(item.description, width / 2, y + 45);
            ctx.fillStyle = "#ff0";
            ctx.fillText(`${item.cost} 젬`, width / 2, y + 70);
          }
          ctx.fillStyle = "#aaa";
          ctx.font = "18px Arial";
          ctx.fillText(
            "↑↓: 선택  SPACE: 구매  ESC: 나가기",
            width / 2,
            height - 50
          );
          ctx.restore();
        }
        handleInput(key) {
          switch (key) {
            case "ArrowUp":
              this.selectedIndex = Math.max(0, this.selectedIndex - 1);
              break;
            case "ArrowDown":
              this.selectedIndex = Math.min(
                this.items.length - 1,
                this.selectedIndex + 1
              );
              break;
            case " ":
              this.purchaseSelected();
              break;
            case "Escape":
              this.game.state = GameState.PLAY;
              break;
          }
        }
        purchaseSelected() {
          const item = this.items[this.selectedIndex];
          if (this.game.gems >= item.cost) {
            this.game.gems -= item.cost;
            item.effect(this.game.player);
          }
        }
      }

      // Game 클래스 (업그레이드 버전: 통합 모달 사용, dt 기반 타이밍 적용, 코드 모듈화 강화)
      class Game {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.state = GameState.TITLE;
          this.lastTime = 0;
          this.storyIndex = 0;
          this.storyTimer = 0;
          this.storyFadeIn = 0;
          this.waveTitleTimer = 0;
          this.wave = 1;
          this.waveTimer = 0;
          this.enemySpawnTimer = 0;
          this.waveStarted = false;
          this.waveClear = false;
          this.introControls = document.getElementById("introControls");
          this.skipIntroBtn = document.getElementById("skipIntro");
          this.startGameBtn = document.getElementById("startGame");
          this.setupEventListeners();
          this.resizeCanvas();
          this.drawGame();
          this.player = new Player(this);
          this.bulletManager = new BulletManager(this);
          this.enemies = [];
          this.itemManager = new ItemManager(this);
          this.effectManager = new EffectManager(this);
          this.particleSystem = new ParticleSystem(this);
          this.shop = new Shop(this);
          this.score = 0;
          this.gems = 0;
          this.customBgColor = null; // 사용자 지정 배경 색상 (옵션 적용 시 사용)
          this.setupOptionsModal();
        }
        setupEventListeners() {
          window.addEventListener("resize", this.resizeCanvas.bind(this));
          document.addEventListener("keydown", this.handleKeyDown.bind(this));
          document.addEventListener("keyup", this.handleKeyUp.bind(this));
          this.canvas.addEventListener(
            "mousedown",
            this.handleMouseDown.bind(this)
          );
          this.skipIntroBtn.onclick = () => {
            this.storyIndex = STORY_TEXT.length;
            this.drawGame();
          };
          this.startGameBtn.onclick = () => {
            this.startGame();
          };
        }
        resizeCanvas() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          this.drawGame();
        }
        startGame() {
          this.state = GameState.PLAY;
          this.waveTitleTimer = 2;
          this.lastTime = performance.now();
          this.introControls.style.display = "none";
          requestAnimationFrame(this.gameLoop.bind(this));
        }
        gameLoop(timestamp) {
          const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1);
          this.lastTime = timestamp;
          this.update(dt);
          this.drawGame();
          requestAnimationFrame(this.gameLoop.bind(this));
        }
        update(dt) {
          if (this.state === GameState.TITLE) this.updateStory(dt);
          else if (this.state === GameState.PLAY) this.updateGame(dt);
        }
        updateStory(dt) {
          if (this.storyIndex < STORY_TEXT.length) {
            this.storyTimer += dt;
            if (this.storyTimer < 1) this.storyFadeIn = this.storyTimer;
            else if (this.storyTimer > 3) {
              this.storyTimer = 0;
              this.storyFadeIn = 0;
              this.storyIndex++;
            }
          }
        }
        updateGame(dt) {
          this.player.update(dt);
          this.bulletManager.update(dt);
          this.updateEnemies(dt);
          this.checkCollisions();
          this.itemManager.update(dt);
          this.effectManager.update(dt);
          this.updateWave(dt);
          this.particleSystem.update(dt);
        }
        updateWave(dt) {
          if (this.state !== GameState.PLAY) return;
          this.waveTimer += dt;
          this.enemySpawnTimer += dt;
          if (!this.waveStarted) {
            this.startWave();
            return;
          }
          if (
            this.enemies.length === 0 &&
            this.waveTimer >= WaveSystem.WAVE_DURATION
          ) {
            this.clearWave();
            return;
          }
          this.spawnEnemies();
        }
        startWave() {
          this.waveStarted = true;
          this.waveClear = false;
          this.waveTimer = 0;
          this.enemySpawnTimer = 0;
          this.waveTitleTimer = 2;
          if (this.wave % WaveSystem.BOSS_WAVE_INTERVAL === 0) this.spawnBoss();
        }
        clearWave() {
          this.wave++;
          this.waveStarted = false;
          this.waveClear = true;
          this.player.hp = Math.min(this.player.hp + 5, this.player.maxHp);
          const baseReward = 2,
            bonus = Math.floor(this.wave / 5);
          this.addGems(baseReward + bonus);
        }
        spawnEnemies() {
          const spawnInterval = Math.max(1 - (this.wave - 1) * 0.1, 0.3);
          if (this.enemySpawnTimer >= spawnInterval) {
            this.enemySpawnTimer = 0;
            if (Math.random() < this.wave * 0.02) this.spawnMiniBoss();
            else this.spawnNormalEnemy();
          }
        }
        spawnNormalEnemy() {
          if (this.enemies.length >= MAX_ENEMIES) return;
          const enemy = new Enemy(this, "normal");
          enemy.hp *= Math.pow(WaveSystem.DIFFICULTY_SCALE, this.wave - 1);
          enemy.maxHp = enemy.hp;
          this.enemies.push(enemy);
        }
        spawnMiniBoss() {
          if (this.enemies.length >= MAX_ENEMIES) return;
          const enemy = new Enemy(this, "miniBoss");
          enemy.hp *= Math.pow(WaveSystem.DIFFICULTY_SCALE, this.wave - 1);
          enemy.maxHp = enemy.hp;
          this.enemies.push(enemy);
        }
        spawnBoss() {
          const boss = new Enemy(this, "boss");
          boss.hp *= Math.pow(WaveSystem.DIFFICULTY_SCALE, this.wave - 1);
          boss.maxHp = boss.hp;
          this.enemies.push(boss);

          // 보스 등장 연출 추가
          if (BOSS_QUOTES[this.wave]) {
            this.showBossQuote(BOSS_QUOTES[this.wave]);
          }
        }
        updateEnemies(dt) {
          this.enemies = this.enemies.filter((enemy) => !enemy.dead);
          for (let enemy of this.enemies) enemy.update(dt);
        }
        drawGame() {
          this.drawBackground();
          if (this.state === GameState.TITLE) {
            this.drawTitleScreen();
          } else if (
            this.state === GameState.PLAY ||
            this.state === GameState.LEVELUP
          ) {
            this.drawPlayScreen();
            if (this.state === GameState.LEVELUP) {
              this.drawLevelUpScreen();
            }
          } else if (this.state === GameState.OVER) {
            this.drawGameOverScreen();
          } else if (this.state === GameState.SHOP) {
            this.shop.draw(this.ctx);
          } else if (this.state === GameState.SKILL_SELECT) {
            this.drawPlayScreen(); // 배경으로 게임 화면을 그림
            this.drawSkillSelectScreen();
          }
        }
        drawBackground() {
          if (this.customBgColor) {
            this.ctx.fillStyle = this.customBgColor;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          } else if (
            this.wave % WaveSystem.BOSS_WAVE_INTERVAL === 0 &&
            this.waveStarted
          ) {
            // 보스 웨이브일 때 붉은 그라데이션 배경
            const grd = this.ctx.createRadialGradient(
              this.canvas.width / 2,
              this.canvas.height / 2,
              50,
              this.canvas.width / 2,
              this.canvas.height / 2,
              this.canvas.width
            );
            grd.addColorStop(0, "#330000");
            grd.addColorStop(1, "#000000");
            this.ctx.fillStyle = grd;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // 추가: 붉은 파티클 효과 (리소스 절감을 위해 particle 수 낮춤)
            if (Math.random() < 0.1) {
              this.particleSystem.createExplosion(
                Math.random() * this.canvas.width,
                Math.random() * this.canvas.height,
                "#ff0000",
                5
              );
            }
          } else {
            // 일반 웨이브: 동적인 별빛 배경을 캐싱하여 매 프레임마다 새로 계산하지 않음
            this.ctx.fillStyle = "#111";
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            if (!this.starField) {
              this.starField = [];
              for (let i = 0; i < 50; i++) {
                this.starField.push({
                  x: Math.random() * this.canvas.width,
                  y: Math.random() * this.canvas.height,
                  size: Math.random() * 2 + 1,
                  alpha: Math.random(),
                });
              }
            }

            this.ctx.fillStyle = "#fff";
            for (let star of this.starField) {
              this.ctx.globalAlpha = star.alpha;
              this.ctx.beginPath();
              this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
              this.ctx.fill();
            }
            this.ctx.globalAlpha = 1;
          }
        }
        drawTitleScreen() {
          this.ctx.save();
          this.ctx.fillStyle = "#fff";
          this.ctx.font = "bold 60px Arial";
          this.ctx.textAlign = "center";
          this.ctx.shadowColor = "#4af";
          this.ctx.shadowBlur = 20;
          this.ctx.fillText("WaveAttack MAX", this.canvas.width / 2, 150);
          if (this.storyIndex < STORY_TEXT.length) {
            this.ctx.globalAlpha = this.storyFadeIn;
            this.ctx.font = "20px Arial";
            this.ctx.fillStyle = "#aaf";
            this.ctx.fillText(
              STORY_TEXT[this.storyIndex],
              this.canvas.width / 2,
              300
            );
          }
          this.ctx.restore();
        }
        drawPlayScreen() {
          this.player.draw(this.ctx);
          this.bulletManager.draw(this.ctx);
          for (let enemy of this.enemies) enemy.draw(this.ctx);
          this.itemManager.draw(this.ctx);
          this.effectManager.draw(this.ctx);
          this.particleSystem.draw(this.ctx);
          this.drawHUD();

          // 보스 대사 표시
          if (this.bossQuote && this.bossQuoteTimer > 0) {
            this.ctx.save();
            this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            this.ctx.fillRect(
              0,
              this.canvas.height / 2 - 100,
              this.canvas.width,
              200
            );

            this.ctx.fillStyle = "#ff4444";
            this.ctx.font = "bold 36px Arial";
            this.ctx.textAlign = "center";
            this.ctx.fillText(
              this.bossQuote.name,
              this.canvas.width / 2,
              this.canvas.height / 2 - 20
            );

            this.ctx.fillStyle = "#ffffff";
            this.ctx.font = "24px Arial";
            this.ctx.fillText(
              this.bossQuote.quote,
              this.canvas.width / 2,
              this.canvas.height / 2 + 20
            );

            this.ctx.restore();
            this.bossQuoteTimer -= 1 / 60;
          }
        }
        drawLevelUpScreen() {
          this.ctx.save();
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.ctx.fillStyle = "#fff";
          this.ctx.font = "bold 48px Arial";
          this.ctx.textAlign = "center";
          this.ctx.shadowColor = "#4af";
          this.ctx.shadowBlur = 20;
          this.ctx.fillText(
            `Level Up! ${this.player.level}`,
            this.canvas.width / 2,
            this.canvas.height / 2
          );

          this.ctx.restore();
        }
        drawGameOverScreen() {
          this.ctx.save();
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.ctx.fillStyle = "#fff";
          this.ctx.font = "bold 60px Arial";
          this.ctx.textAlign = "center";
          this.ctx.shadowColor = "#f00";
          this.ctx.shadowBlur = 20;
          this.ctx.fillText(
            "게임 오버",
            this.canvas.width / 2,
            this.canvas.height / 2 - 50
          );

          this.ctx.font = "30px Arial";
          this.ctx.shadowBlur = 10;
          this.ctx.fillText(
            `최종 점수: ${this.score}`,
            this.canvas.width / 2,
            this.canvas.height / 2 + 20
          );
          this.ctx.fillText(
            `도달한 웨이브: ${this.wave}`,
            this.canvas.width / 2,
            this.canvas.height / 2 + 70
          );

          this.ctx.font = "20px Arial";
          this.ctx.fillText(
            "스페이스바를 눌러 다시 시작",
            this.canvas.width / 2,
            this.canvas.height / 2 + 150
          );

          this.ctx.restore();
        }
        drawHUD() {
          this.ctx.save();
          this.ctx.fillStyle = "#fff";
          this.ctx.font = "16px Arial";
          let x = 20,
            y = 30;
          this.ctx.fillText(`HP: ${this.player.hp}/${this.player.maxHp}`, x, y);
          this.ctx.fillText(`Level: ${this.player.level}`, x, y + 25);
          this.ctx.fillText(
            `XP: ${this.player.xp}/${this.player.nextXp}`,
            x,
            y + 50
          );
          this.ctx.fillText(`Wave: ${this.wave}`, x, y + 75);
          this.ctx.fillText(
            `Time: ${Math.max(
              0,
              Math.ceil(WaveSystem.WAVE_DURATION - this.waveTimer)
            )}s`,
            x,
            y + 100
          );
          this.ctx.fillStyle = "#7DF";
          this.ctx.fillText(`Gems: ${this.gems || 0}`, x, y + 125);
          if (this.waveTitleTimer > 0) {
            this.ctx.save();
            this.ctx.fillStyle = "#fff";
            this.ctx.font = "bold 40px Arial";
            this.ctx.textAlign = "center";
            this.ctx.globalAlpha = Math.min(1, this.waveTitleTimer);
            this.ctx.fillText(
              this.waveClear
                ? `Wave ${this.wave - 1} Clear!`
                : `Wave ${this.wave}`,
              this.canvas.width / 2,
              this.canvas.height / 2
            );
            this.ctx.restore();
            this.waveTitleTimer -= 1 / 60; // Assume 60fps
          }
          this.ctx.restore();
        }
        drawSkillSelectScreen() {
          this.ctx.save();
          // 반투명한 검은색 오버레이
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // 제목
          this.ctx.fillStyle = "#fff";
          this.ctx.font = "bold 40px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText("스킬 선택", this.canvas.width / 2, 150);

          // 스킬 선택지 표시
          const startY = 250;
          const spacing = 120;

          if (this.skillChoices && this.skillChoices.length > 0) {
            this.skillChoices.forEach((skill, index) => {
              const y = startY + spacing * index;
              const isHovered = this.skillHoverIndex === index;

              // 선택지 배경
              this.ctx.fillStyle = isHovered
                ? "rgba(100, 200, 255, 0.3)"
                : "rgba(50, 50, 50, 0.7)";
              this.ctx.fillRect(
                this.canvas.width / 4,
                y - 40,
                this.canvas.width / 2,
                100
              );

              // 스킬 이름
              this.ctx.fillStyle = isHovered ? "#4af" : "#fff";
              this.ctx.font = "bold 24px Arial";
              this.ctx.fillText(skill.name, this.canvas.width / 2, y);

              // 스킬 설명
              this.ctx.fillStyle = "#aaa";
              this.ctx.font = "18px Arial";
              this.ctx.fillText(
                skill.description,
                this.canvas.width / 2,
                y + 30
              );
            });

            // 조작 방법 안내 추가
            this.ctx.fillStyle = "#aaa";
            this.ctx.font = "18px Arial";
            this.ctx.fillText(
              "↑↓: 선택  SPACE/ENTER: 확정",
              this.canvas.width / 2,
              this.canvas.height - 50
            );
          }

          this.ctx.restore();
        }
        handleKeyDown(e) {
          const key = e.key.toLowerCase();

          if (this.state === GameState.SHOP) {
            this.shop.handleInput(e.key);
            return;
          }

          if (this.state === GameState.SKILL_SELECT) {
            switch (e.key) {
              case "ArrowUp":
                this.skillHoverIndex = Math.max(
                  0,
                  (this.skillHoverIndex || 0) - 1
                );
                break;
              case "ArrowDown":
                this.skillHoverIndex = Math.min(
                  2,
                  (this.skillHoverIndex || 0) + 1
                );
                break;
              case " ":
              case "Enter":
                if (
                  this.skillChoices &&
                  this.skillChoices[this.skillHoverIndex]
                ) {
                  const selectedSkill = this.skillChoices[this.skillHoverIndex];
                  selectedSkill.effect(this.player);
                  this.state = GameState.PLAY;
                  this.skillChoices = null;
                  this.skillHoverIndex = 0;
                }
                break;
            }
            return;
          }

          if (this.state === GameState.OVER && key === " ") {
            // 게임 재시작
            this.state = GameState.PLAY;
            this.wave = 1;
            this.score = 0;
            this.gems = 0;
            this.player = new Player(this);
            this.enemies = [];
            this.bulletManager = new BulletManager(this);
            this.itemManager = new ItemManager(this);
            this.waveStarted = false;
            this.waveClear = false;
            this.waveTimer = 0;
            this.enemySpawnTimer = 0;
            return;
          }

          // 스킬 단축키 처리
          if (this.state === GameState.PLAY) {
            switch (key) {
              case "q":
                if (document.getElementById("skill_regenAura")?.checked) {
                  this.player.activateSkill("regenAura");
                }
                return;
              case "w":
                if (document.getElementById("skill_homingLaser")?.checked) {
                  this.player.activateSkill("homingLaser");
                }
                return;
              case "e":
                if (document.getElementById("skill_chainLightning")?.checked) {
                  this.player.activateSkill("chainLightning");
                }
                return;
              case "r":
                if (document.getElementById("skill_meteorShower")?.checked) {
                  this.player.activateSkill("meteorShower");
                }
                return;
            }

            // 방향키만 사용
            switch (key) {
              case "arrowleft":
                this.player.keyState.left = true;
                break;
              case "arrowright":
                this.player.keyState.right = true;
                break;
              case "arrowup":
                this.player.keyState.up = true;
                break;
              case "arrowdown":
                this.player.keyState.down = true;
                break;
              case "tab":
                e.preventDefault();
                this.state = GameState.SHOP;
                break;
            }
          }
        }
        handleKeyUp(e) {
          const key = e.key.toLowerCase();

          // 방향키만 처리
          switch (key) {
            case "arrowleft":
              this.player.keyState.left = false;
              break;
            case "arrowright":
              this.player.keyState.right = false;
              break;
            case "arrowup":
              this.player.keyState.up = false;
              break;
            case "arrowdown":
              this.player.keyState.down = false;
              break;
          }
        }
        handleMouseDown(e) {
          /* 추가 마우스 이벤트 처리 */
        }
        checkCollisions() {
          for (let bullet of this.bulletManager.playerBullets) {
            for (let enemy of this.enemies) {
              if (enemy.dead) continue;
              const dist = this.distance(bullet.x, bullet.y, enemy.x, enemy.y);
              if (dist < enemy.size + bullet.size / 2) {
                enemy.takeDamage(bullet.damage);
                bullet.remove = true;
              }
            }
          }
          for (let bullet of this.bulletManager.enemyBullets) {
            const dist = this.distance(
              bullet.x,
              bullet.y,
              this.player.x,
              this.player.y
            );
            if (dist < this.player.radius + bullet.size / 2) {
              this.player.takeDamage(bullet.damage);
              bullet.remove = true;
            }
          }
          for (let enemy of this.enemies) {
            if (enemy.dead) continue;
            const dist = this.distance(
              enemy.x,
              enemy.y,
              this.player.x,
              this.player.y
            );
            if (dist < enemy.size + this.player.radius)
              this.player.takeDamage(1);
          }
        }
        distance(x1, y1, x2, y2) {
          return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        addScore(value) {
          this.score = (this.score || 0) + value;
        }
        addGems(value) {
          this.gems = (this.gems || 0) + value;
        }
        setupOptionsModal() {
          // Modal 인스턴스 생성
          this.optionsModal = new Modal("optionsModal");

          document
            .getElementById("applyBgColor")
            .addEventListener("click", () => {
              const color = document.getElementById("bgColorPicker").value;
              this.customBgColor = color;
            });

          document
            .getElementById("spawnTestBullet")
            .addEventListener("click", () => {
              this.bulletManager.spawnPlayerBullet(
                this.player.x,
                this.player.y,
                0,
                -1
              );
            });

          document
            .getElementById("simulateLevelUp")
            .addEventListener("click", () => {
              this.player.levelUp();
            });

          document
            .getElementById("spawnTestEnemy")
            .addEventListener("click", () => {
              const enemy = new Enemy(this, "normal");
              enemy.x = this.player.x + 100 * (Math.random() - 0.5);
              enemy.y = this.player.y - 100;
              enemy.hp *= Math.pow(WaveSystem.DIFFICULTY_SCALE, this.wave - 1);
              enemy.maxHp = enemy.hp;
              this.enemies.push(enemy);
            });

          document
            .getElementById("closeOptions")
            .addEventListener("click", () => {
              this.optionsModal.close();
            });

          document
            .getElementById("debugButton")
            .addEventListener("click", () => {
              this.optionsModal.open();
            });
        }
        showBossQuote(bossData) {
          this.bossQuote = bossData;
          this.bossQuoteTimer = 3; // 3초 동안 표시
        }
      }

      const game = new Game();
    </script>
  </body>
</html>
